# Vue

*实现了响应式的效果，我们对处于监听的内容做出修改后，vue会将其任务作为异步处理函数，放入微队列中，正是由于这个原因，vue带来了一个缺陷：要是执行栈中还在运行，vue会一直进行等待，而不会渲染页面，而react则不会。*

> js语言本身的因素，决定它是单线程运行的程序，代码是同步运行的，如果浏览器在执行js代码时出错或由于网速较慢，浏览器无法从远程服务器处加载js文件，或执行js代码期间，由于代码的执行效率低下造成了页面卡顿等等类似因素，vue自身的缺陷就越发明显

## 初探：

- 本质上是一个构造函数，通过new关键词调用，有以下两种方式创建

1）const vm = new Vue({
    el: '需要监听的标签',
    data: {
        需要定义的变量和值，可以通过 插入表达式 显示到页面中，vue也会对其进行监听，实现响应式效果
    }
})

2）const vm = new Vue();
vm.$mount = '需要监听的标签';

- 在监听标签后，我们可以使用实例化对象身上的 $el 属性，读取要监听的标签，然后可以对其进行操作

*vue把data中要监听的属性放到了vue的实例化对象的身上，是为了：更好地实现响应式的效果，更好地监听属性的变化；减少开发者在使用时，可能由于嵌套过深而不得已使用递归访问的性能损耗*

- vue使用了两个形式的自定义变量命名规则：$ 和 _ ，前者是提供给开发者使用的；后者是vue内部使用的。

> 这么做的原因是：避免命名冲突

### 插入表达式：{{  }}

- 中间可以书写：数字、函数、字符串、对象、布尔值、运算、数组

- 不能书写：逻辑表达式、条件判断语句、申明变量等操作

*注意：如果书写了 未经申明的变量 或 从未使用的变量，vue不会重新渲染页面*

```yaml
作用域上找不到的会报错；原型链上找不到的会输出undefined
```

> 这么做的原因是：重新渲染页面会损耗性能，可能会造成浏览器访问页面时卡顿，vue考虑到了用户体验，而做出的优化

### 有两个特殊情况，vue对其的变化无法监听：

1）通过数组索引位改变元素的值 或 改变数组的 length 长度

2）增加对象的没有经过定义过的属性 或 删除已有属性

*无法监听的原因是：vue2内部使用的是 Object.defineProperty，是这个方法内部的缺陷*

- 针对第一种情况，vue重写了数组身上的七个方法，让我们可以监听数组中元素的变换

> 分别为：pop、push、shift、unshift、splice、sort、reverse

- 针对第二种情况，vue提供了两种方法，也可以作用于数组，但一般使用上述的七种方法

> 分别为：$set('要修改的对象', '要修改的属性名', '要修改的值') 和 $delete('要删除的对象', '要删除的属性名')

> 如果作用的是：$set('要修改的数组', '要修改的索引位', '要修改的值') 和 $delete('要删除的数组', '要删除的索引位')

### nextTick：

- vue提供了一个在vue渲染页面后立即执行的微队列函数，这个函数就是 nextTick，也提供了两个调用方法

1）通过Vue自身调用（Vue.nextTick）

2）通过vue的实例化对象调用（vm.$nextTick）

*两个调用方式没有本质区别，不同的是：第一种方式中的this指向window；第二种方式中的this指向调用者本身；$set 和 $delete，vue也提供了一样的调用方式，两者没有本质区别，通过第二种调用的方式是第一种方式调用的别名*

明天任务：模拟vue2内部使用 Object.defineProperty方法，监听已经定义的属性变化，实现响应式的效果