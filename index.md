# Vue

*实现了响应式的效果，我们对处于监听的内容做出修改后，vue会将其任务作为异步处理函数，放入微队列中，正是由于这个原因，vue带来了一个缺陷：要是执行栈中还在运行，vue会一直进行等待，而不会渲染页面，而react则不会。*

> js语言本身的因素，决定它是单线程运行的程序，代码是同步运行的，如果浏览器在执行js代码时出错或由于网速较慢，浏览器无法从远程服务器处加载js文件，或执行js代码期间，由于代码的执行效率低下造成了页面卡顿等等类似因素，vue自身的缺陷就越发明显

## 初探：

- 本质上是一个构造函数，通过new关键词调用，有以下两种方式创建

1）const vm = new Vue({
    el: '需要监听的标签',
    data: {
        需要定义的变量和值，可以通过 插入表达式 显示到页面中，vue也会对其进行监听，实现响应式效果
    }
})

2）const vm = new Vue();
vm.$mount = '需要监听的标签';

- 在监听标签后，我们可以使用实例化对象身上的 $el 属性，读取要监听的标签，然后可以对其进行操作

*vue把data中要监听的属性放到了vue的实例化对象的身上，是为了：更好地实现响应式的效果，更好地监听属性的变化；减少开发者在使用时，可能由于嵌套过深而不得已使用递归访问的性能损耗*

- vue使用了两个形式的自定义变量命名规则：$ 和 _ ，前者是提供给开发者使用的；后者是vue内部使用的。

> 这么做的原因是：避免命名冲突

### 插入表达式：{{  }}

- 中间可以书写：数字、函数、字符串、对象、布尔值、运算、数组

- 不能书写：逻辑表达式、条件判断语句、申明变量等操作

*注意：如果书写了 未经申明的变量 或 从未使用的变量，vue不会重新渲染页面*

```yaml
作用域上找不到的会报错；原型链上找不到的会输出undefined
```

> 这么做的原因是：重新渲染页面会损耗性能，可能会造成浏览器访问页面时卡顿，vue考虑到了用户体验，而做出的优化

### 有两个特殊情况，vue对其的变化无法监听：

1）通过数组索引位改变元素的值 或 改变数组的 length 长度

2）增加对象的没有经过定义过的属性 或 删除已有属性

*无法监听的原因是：vue2内部使用的是 Object.defineProperty，是这个方法内部的缺陷*

- 针对第一种情况，vue重写了数组身上的七个方法，让我们可以监听数组中元素的变换

> 分别为：pop、push、shift、unshift、splice、sort、reverse

- 针对第二种情况，vue提供了两种方法，也可以作用于数组，但一般使用上述的七种方法

> 分别为：$set('要修改的对象', '要修改的属性名', '要修改的值') 和 $delete('要删除的对象', '要删除的属性名')

> 如果作用的是：$set('要修改的数组', '要修改的索引位', '要修改的值') 和 $delete('要删除的数组', '要删除的索引位')

### nextTick：

- vue提供了一个在vue渲染页面后立即执行的微队列函数，这个函数就是 nextTick，也提供了两个调用方法

1）通过Vue自身调用（Vue.nextTick）

2）通过vue的实例化对象调用（vm.$nextTick）

*两个调用方式没有本质区别，不同的是：第一种方式中的this指向window；第二种方式中的this指向调用者本身；$set 和 $delete，vue也提供了一样的调用方式，两者没有本质区别，通过第二种调用的方式是第一种方式调用的别名*

明天任务：模拟vue2内部使用 Object.defineProperty方法，监听已经定义的属性变化，实现响应式的效果

-- 完成

## 相关指令：

- vue提供了一系列可供我们使用的指令，这些指令为了防止命名冲突，vue在每个可使用的指令前加上了 v-，根据需求，运用相应的指令

### 基本指令：

*vue不支持IE8及以下版本，原因见下：*

1）v-pre：不解析该标签，如果使用了data中的属性，vue也不会做任何处理

2）v-once：只会执行一次

3）v-html：会将字符串中的内容当做html元素来执行，由于会改变页面中的html结构，永不在用户的提交按钮上使用，以防xss攻击

4）v-text：会将字符串中的内容当做文本替换到对应的位置

5）v-cloak：避免闪烁，用于如果用户网速不佳，给页面一个遮罩层，不会提前展示花括号，影响影虎体验，当浏览器读取js文件后，将内容替换后，再一起显示

*textContent和innerText的异同：*

1）textContent根据的是代码显示；innerText根据的是浏览器的渲染显示

2）textContent会读取设置display为none的标签中的文本；innerText则不会

3）textContent是标准获取文本的方法；innerText是IE8及以下支持的

4）如果在标签内嵌套了style和script标签，textContent获取其中的文本；innerText则不会

5）textContent一般不会触发重排，一般只会触发重绘；innerText则会

> 为了更好地优化页面的性能，vue使用的是textContent方法

### 条件渲染：

*五个判断为false的值：undefined、false、0、""、null*

1）v-if：如果条件满足，执行指令

2）v-else-if：如果上面的条件不满足，则看这个条件是成立；如果成立，执行指令

3）v-else：如果上述条件都不满足，看这个条件是否成立；如果成立，执行指令

4）v-show：类似于v-if，如果条件成立，执行指令

> 在vue中可以使用template，如果标签中是纯文本，而我们需要对这个标签进行显示与隐藏，配合使用这个标签，可以不生成额外的标签，该标签是隐式标签

*v-if和v-show的异同：*

1）都是条件渲染指令，条件为真，才会执行

2）如果条件为假，v-if会将标签移除；v-show只是切换标签的display值为none

3）v-if可以配合template使用；v-show不行

4）v-if是惰性加载，如果一开始条件为假，不会进行渲染；v-show不管条件是否为真，都会进行渲染

- 根据上面的不同，使用时考虑优化性能：

1）如果要对一个标签，频繁地进行切换与显示，用v-show

2）如果确定一个标签的状态，比如说一开始就不显示，用v-if

## v-bind指令：

> 我们可以使用这一指令，让自定义属性添加到标签身上，成为可以操作的特性

- 如果想静态绑定，直接用data中的属性名；如果是想动态绑定，用类似于es6中的语法 [属性名]

为了简化书写和提高阅读性，vue提供了该指令的简写，直接用 : 代替，实现相应的效果

### 绑定的三种方法：

1）用无参数的对象，注意此时不能简写为 :

2）可以使用data中定义好的对象的属性名

3）可以使用data中定义好的数组

我们可以使用条件判断，用于是否添加class类名，如果为true，添加；否则，不添加

*vue内部自带了添加厂商前缀的功能*

- 修饰符：

html特性，会将书写的大写字母转换为小写

1）camel：取消这一特性

> 如果要使用的话，用小写字母，通过 - 连接，这一修饰符会转换为小驼峰式命名规则

2）prop：绑定dom的属性，成为特性

3）sync：后续认识

*如果要在行间书写属性或特性，使用小写字母，中间通过 -  连接*

## v-on指令：

类似于原生js中的用on绑定事件的效果

通过 v-on:事件处理名，也可以使用 @事件处理名，在methods中书写

> 和原生的js一样，在点击的时候，可以传递一个e，里面记录了关于该标签信息，通过e.target方法可以获取点击标签的事件源；如果已经传递了一个参数，还想获取点击的事件源的话，最后一个参数，通过 $event 传递

*vue将关于dom的操作与逻辑代码完成分割，更有利于维护和阅读；在ViewModel被销毁时，vue会自动删除无效的事件监听和处理*

> vue将处理函数和数据中的属性一样，通过实例化对象直接调用，我们轻松地使用this，而无需考虑指向问题

### 事件修饰符：

1）.stop：阻止冒泡

2）.prevent：阻止默认的事件，比如点击提交后，表单会进行提交，页面会刷新

3）.once：只会执行一次

4）.capture：开启捕获事件

5）.passive：使用了该修饰符的标签，浏览器不会对其监听，会忽略它的事件，直接执行，一般用于移动端，当用户向上滑动屏幕时，页面跟着上移，这个时候，该修饰符可以帮助我们优化用户体验，让屏幕直接做出反应

6）.self：只执行自身的事件

*事件可以并用，这种情况发生时，考虑先后顺序*

> 比如说：.prevent.self：是先阻止所有的默认事件，再只执行自身的事件；.self.prevent：是先执行自身的事件，再阻止其自身的默认事件

> .passive 和 .prevent 不能并用，自相矛盾

### 按键修饰符：.left、.right、.up、.down、.tab、.esc、.space、.enter、.delete

### 系统修饰符：.shift、.ctrl、.meta（不同的操作系统，按键的名称不同，win下是“田”；mac下是command）、.caps-lock

### 鼠标修饰符：.left、.right、.middle，分别对应的是鼠标的左右键和中间的滑轮

### 可以使用keyCode的值，但不建议这么绑定，因为已被逐渐废除

> 比如说：.13 对应的是就是 .enter

### 可以使用Key Values的值

> 比如说：.arrow-left 对应的就是 .left

### 我们也可以自定义Key Values的值，绑定想要的按键

> Vue.config.字母 = "Number类型的数值"

*以上修饰符可以并用，也可以使用 .exact 精确地绑定按键*

## 列表渲染（v-for）：

通过v-for指令可以遍历data中的数组或对象

1）如果是数组，可以传递两个参数，对应的是：(value, index) in / of 数组名

2）如果是对象，可以传递三个参数，对应的是：(value, key, index) in / of 对象名

*vue建议使用 of 获取对象或数组中的值，因为更接近 迭代器语法，但一般使用 in 遍历*

> 注意：如果要实现遍历，需要配合使用 ul 和 li 标签，只要在一个 li 身上添加 v-for 指令就可以遍历得到所有数据，如果要在标签内显示，用插值表达式 {{ }}

- 有个小练习，点击按钮，将其下移，具体实现见页面

> 使用 key 值绑定唯一标识，不同的是：不建议使用 index 索引绑定，为了优化性能，如果使用了 index，vue会比较前后的名称变化，变动过的属性的索引位上的值与原先的不符，vue会重新渲染标签，触发重排，损耗一定的性能；但是如果使用的是其他，那么不会这样，vue只是更改其标签内的文本信息，而不会对dom做出操作，只会触发重绘

*使用 key 绑定时，只能是：字符串 或 数字*

### v-for 和 v-if 不建议同时使用，原因如下：

> v-for 的优先级比 v-if 要高，所以即使是有条件判断，vue还是会将父标签内的所有标签渲染，再去看条件判断，是否显示或隐藏某些标签，性能有一定的损耗

如果一定要配合使用的话，那么可以使用如下两种方式：

1）我们可以手动地过滤 data 中的属性值，再用 v-if 判断是否显示与隐藏（比较 low，不建议采用，后面有更好的解决办法）

2）可以在父标签身上使用 v-if 指令，利用 v-if 懒加载的特性，可以减少一定的性能开销

## v-model指令：

*可以实现：双向数据绑定，也叫双向链路*

可以用于以下场景：

input[type="text"]，结果是一个字符串

input[type="checkbox"]，结果是一个数组

input[type="radio"]，结果是一个字符串

select，结果是一个字符串，通常添加一个额外的option标签，用于展示关于选项的介绍信息，为了更好的用户体验，给该标签添加一个disabled属性

### 修饰符：

1）number：获取的文本类型是字符串，如果输入的是数字，通过该修饰符，可以获取数值

2）trim：可以去除文本左右多余的空格，当失去焦点的时候就会触发

3）lazy：懒获取，只有当失去焦点时才会触发，而不是不断地进行监听，更好地优化性能

## 侦听器

*当监听的属性发生变化时，就会执行其中的代码*

> 可以传递两个参数，分别对应的是：newValue，oldValue 的值

可以是以下几种形式：

1）监听属性() {}

2）监听属性: ''，字符串中是在methods中要执行的方法

3）'监听属性'，可以具体监听对象中的某个属性

4）监听属性：{
        handler() {}, // 必填
        deep: false, // 选填，无论嵌套多深，只要改变了，就能监听，浪费性能，一般只会监听某个具体的属性
        - 在监听数组时，该属性不需要设置
        immediate: false // 选填，只要监听就会生效，不管值是否发生变化
    }

以上是在vue实例化对象中的watch属性中设置，也可以在vue实例化对象自身上设置，如下：

1）vm.$watch('监听属性', function(){}, deep 和 immediate 配置)

2）vm.$watch('监听属性', {
    handler() {}, // 同上
    deep: false, // 同上
    immediate: false // 同上
})

> 监听器返回结果是一个函数，vue提供了一个取消监听的方法，一般用 unwatch 来接收；注意如果想要在一开始就取消监听，可以配合 return，只能用 var 定义，别忘了加上判断是否 unwatch 存在，不然会报错

*监听器和计算属性的异同：*

1）都可以监听属性的变化

2）监听器针对的是：一个数据处理多个数据；计算属性针对的是：多个属性处理一个数据

3）监听器内部可以写异步处理函数；计算属性不行

> 计算属性一定要 return，返回的结果就是计算属性的值；监听器可以不需要，如果在计算属性内部写了异步处理函数，执行步骤是：先返回结果，渲染，再得到异步处理函数中的值，重新赋值，再渲染，浪费性能；监听器可以完美解决这一问题，因为本身支持